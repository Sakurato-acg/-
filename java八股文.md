# 编程语言

> 请你说说Java的特点和优点,为什么要选择Java？

1. 一次编译，到处运行，即`平台无关性`；是纯`面向对象`的语言。
2. JAVA语言的优点有：内置的类库简化了开发人员的设计工作；具有较好的安全性和健壮性；开发人员不需要对内存的使用进行管理。
3. 选择JAVA的原因是：使用范围很广，安卓操作系统的应用软件目前大部分还是使用JAVA语言编写。

> 请你说说Java基本数据类型和引用类型

1. 提供8种基本数据类型：byte(8), short(16), int(32), long(64), float(32), double(64), char(16), boolean，这些基本数据类型有对应的封装类；这基本数据类型在声明之后就会立刻在**栈**上被分配内存空间
2. 其他类型都是引用类型：类，接口，数组，String等，这些变量在声明时**不会被分配内存空间**，只是存储了一个**内存地址**。

> 请你说一下抽象类和接口的区别

相同点：

1、两者都不能实例化；

2、可以拥有抽象方法。 

区别：

1、抽象类定义的关键字是abstract class，接口定义的关键字是interface；

2、属性上，抽象类可以有静态变量、常量和成员变量，接口只能有常量；

3、抽象方法可以有普通方法，而接口jdk1.8之前只能有抽像方法（1.8之后，增加了静态方法和默认方法）；

4、抽象方法可以有构造方法，接口不可以有构造方法。

5、一个类只能单继承一个父类，而一个接口可以继承多个父接口，同时，一个类可以实现多个接口却没有实现多个父类这一说法；

6、抽象方法在业务编程上更像一个模板，有自己的功能，同时也可以有优化补充的多种形式，而接口更像是一种规范和要求，实现就要按照要求来进行。

> 请你说一下final关键字

1. final可以修饰类，方法，变量。 
2. final修饰类，该类不可被继承。 
3. final修饰方法，该方法不能被重写。 final修饰变量，如果是基本变量则值不能再改变，如果是引用变量则引用地址不能改变，但值可以改变。

> 说说static修饰符的用法

1. static修饰变量：属于静态变量也叫类变量，直属于类对象而不是实例，可以通过类名访问，它一般会在类加载过程中被初始化。生命周期贯穿整个程序。存储在方法区中。
2.  static修饰方法：即静态方法，一个类中的静态方法不能访问该类的实例变量，只能访问静态变量。同时还存在一个静态初始化块，他在类加载过程中被调用用于对该类中的静态变量进行操作。 
3. static修饰类：即静态内部类，他只能以内部类的形式存在，可通过外部类的类名调用。它是他也只能访问到外部的的静态成员。

> 请你说说String类,以及new和

1. String类被final修饰，所以不能被继承。
2. 创建String对象时可以使用字符串直接量，如String str="1abc", 另一种String str=new String("1abc")
3. 前者使用常量池来管理，后者先判断常量池中是否已存在此字符串，不存在就也在常量池创建，再在堆内存创建一个新的对象，因此后者开销更大

> String、StringBuffer、Stringbuilder有什么区别

1. String是不可变字符序列，从它创建到销毁前，都不可变。
2. StringBuilder是可变字符序列，但不是线程安全的。
3. StringBuffer是可变字符序列，与StringBuilder功能相似，区别是它是线程安全的。 
4. 相比String，StringBuilder有append()方法，即追加字符串。最后toString()转换成String

> 请你说说==与equals()的区别

1. == 比较基本数据类型时，比较的是两个数值是否相等； 比较引用类型是，比较的是对象的内存地址是否相等。 
2. equals() 没有重写时，Object默认以==来实现，即比较两个对象的内存地址是否相等； 重写以后，按照对象的内容进行比较

> 请你说说hashCode()和equals()的区别,为什么重写equals()就要重写hashcode()

1. hashCode()：获取哈希码,equals()：比较两个对象是否相等。
2. 二者两个约定：如果两个对象相等,它们必须有相同的哈希码；若两个对象的哈希码相同,他们却不一定相等。也就是说,equals()比较两个对象相等时hashCode()一定相等,hashCode()相等的两个对象equqls()不一定相等。
3. 加分回答：由于hashCode()与equals()具有联动关系,equals()重写时,hashCode()进行重写,使得这两个方法始终满足相关的约定。

> 请你讲一下Java 8的新特性

- **Lambda 表达式** − Lambda 允许把函数作为一个方法的参数（函数作为参数传递到方法中）。
- **方法引用** − 方法引用提供了非常有用的语法，可以直接引用已有Java类或对象（实例）的方法或构造器。与lambda联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。
- **默认方法** − 默认方法就是一个在接口里面有了一个实现的方法。
- **新工具** − 新的编译工具，如：Nashorn引擎 jjs、 类依赖分析器jdeps。
- **Stream API** −新添加的Stream API（java.util.stream） 把真正的函数式编程风格引入到Java中。
- **Date Time API** − 加强对日期与时间的处理。
- **Optional 类** − Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。
- **Nashorn, JavaScript 引擎** − Java 8提供了一个新的Nashorn javascript引擎，它允许我们在JVM上运行特定的javascript应用。

> 介绍一下包装类的自动拆装箱与自动装箱

1. 自动装箱、自动拆箱是JDK1.5提供的功能。
2. 自动装箱：把一个基本类型的数据直接赋值给对应的包装类型；
3. 自动拆箱是指把一个包装类型的对象直接赋值给对应的基本类型；
4. 通过自动装箱、自动拆箱功能,简化基本类型变量和包装类对象之间的转换过程

> 请你说说Java的异常处理机制

1. 异常处理机制让程序具有`容错性`和`健壮性`,程序运行出现状况时,系统会生成一个`Exception对象`来通知程序
2. 处理异常的语句由try、catch、finally三部分组成。try块用于包裹业务代码,catch块用于捕获并处理某个类型的异常,finally块则用于回收资源。
3. 如果业务代码发生异常,系统创建一个异常对象,并将其提交给JVM,由JVM寻找可以处理这个异常的catch块,并将异常对象交给这个catch块处理。如果JVM没有找到，运行环境终止,Java程序退出。
4. Java也允许程序主动抛出异常。当业务代码中,判断某项错误的条件成立时,可以使用throw关键字向外抛出异常。

> 说说你对面向对象的理解

1. 面向对象三大基本特征：`封装`、`继承`、`多态`。
2. 封装：将对象的状态信息隐藏在对象内部,不允许外部程序直接访问对象内部信息,让外部程序通过该类提供的方法来实现对内部信息的操作和访问,提高了代码的可维护性；
3. 继承：实现代码复用的重要手段,通过extends实现类的继承,实现继承的类被称为子类,被继承的类称为父类；
4. 多态的实现离不开继承,在设计程序时,我们可以将参数的类型定义为父类型。在调用程序时根据实际情况,传入该父类型的某个子类型的实例,这样就实现了多态。

> 请介绍一下访问修饰符

1. Java中的访问修饰符有四种，分别为private,default,protected,public。
2. private：类中被private修饰的只能在被当前类的内部访问
3. default：类中被default修饰的只能在当前类和当前类所在包的其他类访问。
4. protected：类中被protected修饰的可以被当前类和当前类所在的包的其他类以及子类访问。
5. public：类中被public修饰的能被当前项目下的所有类访问。

> 请说说你对反射的了解

1. 反射就是在程序运行期间动态的获取对象的属性和方法的功能叫做反射。它能够在程序运行期间，对于任意一个类，都能知道它所有的方法和属性，对于任意一个对象，都能知道他的属性和方法。
2.  获取Class对象的三种方式：`getClass()`;`xx.class`;`Class.forName("xxx")`; 
3. 反射的优缺点： 
   1. 优点：运行期间能够动态的获取类，提高代码的灵活性。
   2.  缺点：性能比直接的Java代码要慢很多。 应用场景：spring的xml配置模式，以及动态代理模式都用到了反射

> 请你说说多线程

1. 线程是程序执行的最小单元，一个进程可以拥有多个线程 
2. 各个线程之间共享程序的内存空间（代码段、数据段和堆空间）和系统分配的资源（CPU，I/O，打开的文件），但是各个线程拥有自己的栈空间
3. 多线程优点：减少程序响应时间；提高CPU利用率；创建和切换开销小；数据共享效率高；简化程序结构

> 说说线程的创建方式

创建线程有3种方式：

1. 继承Thread类，重写run()方法；
2. 实现Runnable接口，并实现该接口的run()方法；
3. 3.实现Callable接口，重写call()方法。
4. 前两种方式线程执行完后都没有返回值，最后一种带返回值；一般推荐实现Runnable接口的方式。

> 说说怎么保证线程安全

 		 线程安全问题是指在多线程背景下，线程没有按照我们的预期执行，导致操作共享变量出现异常。在Java中有许多同步方案提供给我们使用，从轻到重有三种方式：原子类、volatile关键字、锁。 

1. 原子类是juc atomic包下的一系列类，通过CAS比较与交换的机制实现线程安全的更新共享变量。通过预期值与内存值的比较来判断是否修改。
2. volatile关键字是轻量级的同步机制，他实现了变量的可见性、防止指令重排序。保证了【单个变量】读写的线程安全。可见性问题是JMM内存模型中定义每个核心存在一个内存副本导致的，核心只操作他们的内存副本，volatile保证了一旦修改变量则立即刷新到共享内存中，且其他核心的内存副本失效，需要重新读取。
3.  原子类和volatile只能保证单个共享变量的线程安全，锁则可以保证临界区内的多个共享变量线程安全。java中常用的锁有两种：synchronized+juc包下的lock锁。synchronized锁是互斥锁，可以作用于实例方法、静态方法、代码块，基于对象头和Monitor对象，在1.6之后引入轻量级锁、偏向锁等优化。lock锁接口可以通过lock、unlock方法锁住一段代码，基于AQS实现，其加锁解锁就是操作AQS的state变量，并且将阻塞队列存在AQS的双向队列中。除了锁以外，juc包下还提供了一些线程同步工具类，如CountDownLatch、Semaphore等等，我们还可以使用ThreadLocal定义线程局部变量！

> 说说Java中常用的锁及原理

对象头、AQS标准；Java中加锁有两种方式，分别是synchronized关键字和Lock接口，而Lock接口的经典实现是ReentrantLock

> 说说你对ThreadLocal的理解

1. ThreadLocal是线程变量，它将需要共享的数据复制多份，每个线程各一份。
2. 内部使用了一个ThreadLoadMap来存储信息，key是当前线程，而value是我们需要传输的数据，我们可以在线程执行的过程中通过get/set，操作map中的数据
3. 不过需要注意的是在使用线程池的时候，线程执行完毕不会被销毁，而是进入线程池中等待，这个时候我们需要手动释放一下map中的数据，以免造成内存浪费。

> 请说说你对Java集合的了解

1. java中的集合类主要都有Collection和Map这两个接口派生而出，其中Collection又派生出List,Set,Queue。
2. 所有的集合类都是List,set,queue,map这四个接口的实现类。
3. 其中，list代表有序的，可重复的数据集合；set代表无序的，不可重复的数据集合，queue代表先进先出的队列；map是具有映射关系的集合。
4. 最常用的实现类又ArrayList,LinkedList,HashMap,TreeMap,HashSet,TreeSet,ArrayQueue。

> 请你说说HashMap底层原理

1. 在1.8之前，HashMap的底层是数组加链表，在1.8之后是数组+链表+红黑树； 
2. 它的put流程是：基于哈希算法来确定元素位置，当我们向集合存入数据时，他会计算传入的key的哈希值，并利用哈希值取绝对值再根据集合长度取余来确定元素的位置，如果这个位置已经存在其他元素了，就会发生哈希碰撞，则hashmap就会通过链表将这些元素组织起来，如果链表的长度达到8时，就会转化为红黑树，从而提高查询速度。 
3. 扩容机制：HashMap中数组的默认初始容量为16，当达到默认负载因子0.75时，会以2的指数倍进行扩容。 Hashmap时非线程安全的，在多线程环境下回产生循环死链，因此在多线程环境下建议使用ConcurrentHashMap。